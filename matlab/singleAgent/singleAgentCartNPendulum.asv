classdef singleAgentCartNPendulum < rl.env.MATLABEnvironment
    %SINGLEAGENTCARTNPENDULUM: Template for defining custom environment in MATLAB.    
    
    %% Properties (set properties' attributes accordingly)
    properties
                % Mass of Pendulum (kg)
        mp = 4;

        % Mass of Cart (kg)
        mc = 2;

        % Length of Pole (m)
        d = 1;

        % Gravity (m/s^2)
        g = 10;

        % Goal State
        theta_target = 0; % in rad
        thetadot_target = 0; % in rad/s
        x_target = 0; % in m/s
        xdot_target = 0; % in m/s
        
        % Rated Torque of Motors
        % rated_torque_cart = 6*this.g/100;
        % wheel_rad = 0.05;
        % MaxForce = rated_torque_cart/wheel_rad;
        MaxForce = 12;
        
        % Inertia of System
        Ig = 0;
        I = 0;

        % Viscous Drag
        b = 1;

        % Sample time
        Ts = 0.01

        % Figure Initialisation
        Figure;
        
        % Angle at which to fail the episode (radians)
        AngleThreshold = 12 * pi/180
        
        % Distance at which to fail the episode
        DisplacementThreshold = 2.4
        
        % Reward each time step the cart-pole is balanced
        RewardForNotFalling = 1/
        
        % Penalty when the cart-pole fails to balance
        PenaltyForFalling = -10
    end
    
    properties
        % Initialize system state [x,dx,theta,dtheta]'
        State = zeros(4,1)
    end
    
    properties(Access = protected)
        % Initialize internal flag to indicate episode termination
        IsDone = false        
    end

    %% Necessary Methods
    methods              
        % Contructor method creates an instance of the environment
        % Change class name and constructor name accordingly
        function this = singleAgentCartNPendulum()
            % Initialize Observation settings
            ObservationInfo = rlNumericSpec([4 1]);
            ObservationInfo.Name = 'CartPole States';
            ObservationInfo.Description = 'x, dx, theta, dtheta';
            
            % Initialize Action settings   
            ActionInfo = rlFiniteSetSpec(-12:12);
            % ActionInfo = rlNumericSpec([1 1], 'LowerLimit', -12, 'UpperLimit', 12);
            ActionInfo.Name = "CartPole Action";

            % ActionInfo.Name = 'CartPole Action';
            
            % The following line implements built-in functions of RL env
            this = this@rl.env.MATLABEnvironment(ObservationInfo,ActionInfo);

            this.Figure = [];
            
            % Initialize property values and pre-compute necessary values
            updateActionInfo(this);
        end
        
        % Apply system dynamics and simulates the environment with the 
        % given action for one step.
        function [Observation,Reward,IsDone,Info] = step(this,Action)
            Info = [];
            
            % Get action
            F = getForce(this,Action);            
            
            % Unpack state vector
            xdot = this.State(2);
            theta = this.State(3);
            thetadot = this.State(4);
            
            % Apply motion equations            
            xddot = (this.I*F + this.d^2*this.mp*F - this.I*this.b*xdot - ...
                this.b*this.d^2*this.mp*xdot - this.d^3*this.mp^2* ...
                thetadot^2*sin(theta) + ...
                this.d^2*this.g*this.mp^2*cos(theta)*sin(theta) - ...
                this.I*this.d*this.mp*thetadot^2* ...
                sin(theta)) / (this.I*this.mc + this.I*this.mp + ...
                this.d^2*this.mp^2 - this.d^2*this.mp^2* ...
                cos(theta)^2 + this.d^2*this.mc*this.mp);
            
            thetaddot = (this.d*this.mp*F*cos(theta) ...
                + this.d*this.g*this.mp^2*sin(theta) - this.d^2*this.mp^2* ...
                thetadot^2*cos(theta)*sin(theta) - this.b*this.d*this.mp* ...
                xdot*cos(theta) + this.d*this.g*this.mc*this.mp* sin(theta)) ...
                / (this.I*this.mc + this.I*this.mp + this.d^2*this.mp^2 - ...
                this.d^2*this.mp^2*cos(theta)^2 + this.d^2*this.mc*this.mp);

            
            % Euler integration
            Observation = this.State + this.Ts.*[xdot;xddot;thetadot;thetaddot];

            % Update system states
            this.State = Observation;
            
            % Check terminal condition
            X = Observation(1);
            Theta = Observation(3);
            IsDone = abs(X) > this.DisplacementThreshold || abs(Theta) > this.AngleThreshold;
            this.IsDone = IsDone;
            
            % Get reward
            Reward = getReward(this);
            
            % (optional) use notifyEnvUpdated to signal that the 
            % environment has been updated (e.g. to update visualization)
            notifyEnvUpdated(this);
        end
        
        % Reset environment to initial state and output initial observation
        function InitialObservation = reset(this)
            % Theta (+- .05 rad)
            T0 = 2 * 0.05 * rand - 0.05;  
            % Thetadot
            Td0 = 0;
            % X 
            X0 = 0;
            % Xdot
            Xd0 = 0;
            
            InitialObservation = [X0;Xd0;T0;Td0];
            this.State = InitialObservation;
            
            % (optional) use notifyEnvUpdated to signal that the 
            % environment has been updated (e.g. to update visualization)
            notifyEnvUpdated(this);
        end
    end
    %% Optional Methods (set methods' attributes accordingly)
    methods               
        % Helper methods to create the environment
        % Discrete force 1 or 2
        function force = getForce(this,action)
            if ~ismember(action,this.ActionInfo.Elements)
                error('Action must be %g for going left and %g for going right.',-this.MaxForce,this.MaxForce);
            end
            force = action;           
        end
        % update the action info based on max force
        function updateActionInfo(this)
            % Ensure ActionInfo is of type rlFiniteSetSpec
            this.ActionInfo = rlFiniteSetSpec(this.MaxForce * [-1, 1]); 
            this.ActionInfo.Name = "CartPole Action"; 
        end

        
        % Reward function
        function Reward = getReward(this)
            if ~this.IsDone
                Reward = this.RewardForNotFalling;
            else
                Reward = this.PenaltyForFalling;
            end          
        end
        
        % (optional) Visualization method
        function plot(this)
            % Extract state variables
            x = this.State(1);   % Cart position
            theta = this.State(3); % Pendulum angle
        
            % Define cart and pendulum dimensions
            pendulum_length = this.d;
            cart_width = pendulum_length/2;
            cart_height = pendulum_length/8;
            
        
            % Initiate figure and hold on to overlay multiple plots
            if  ~isvalid(this.Figure) ||isempty(this.Figure)
                this.Figure = figure();
                hold on;
                axis equal;
                xlim([-2, 2]); 
                ylim([-1, 1]);
                xlabel('X-axis');
                ylabel('Y-axis');
                title('Cart-Pendulum System');
                
                % Draw cart
                this.CartPlot = plot([x-cart_width/2, x+cart_width/2, x+cart_width/2, x-cart_width/2, x-cart_width/2], ...
                                     [0, 0, -cart_height, -cart_height, 0], 'w', 'LineWidth', 2);
                
                % Draw pendulum
                this.PendulumPlot = plot([x, x + pendulum_length*sin(-theta)], ...
                                         [0, pendulum_length*cos(theta)], 'b', 'LineWidth', 2);
        
                hold off;
            else
                % Update cart position
                set(this.CartPlot, 'XData', [x-cart_width/2, x+cart_width/2, x+cart_width/2, x-cart_width/2, x-cart_width/2]);
                
                % Update pendulum position
                set(this.PendulumPlot, 'XData', [x, x + pendulum_length*sin(-theta)], ...
                                       'YData', [0, pendulum_length*cos(theta)]);
            end
        
            % Refresh plot
            drawnow;
            
            % Call the environment update callback
            envUpdatedCallback(this);
        end

        
        % (optional) Properties validation through set methods
        function set.State(this,state)
            validateattributes(state,{'numeric'},{'finite','real','vector','numel',4},'','State');
            this.State = double(state(:));
            notifyEnvUpdated(this);
        end
        function set.Ts(this,val)
            validateattributes(val,{'numeric'},{'finite','real','positive','scalar'},'','Ts');
            this.Ts = val;
        end
        function set.AngleThreshold(this,val)
            validateattributes(val,{'numeric'},{'finite','real','positive','scalar'},'','AngleThreshold');
            this.AngleThreshold = val;
        end
        function set.DisplacementThreshold(this,val)
            validateattributes(val,{'numeric'},{'finite','real','positive','scalar'},'','DisplacementThreshold');
            this.DisplacementThreshold = val;
        end
        function set.RewardForNotFalling(this,val)
            validateattributes(val,{'numeric'},{'real','finite','scalar'},'','RewardForNotFalling');
            this.RewardForNotFalling = val;
        end
        function set.PenaltyForFalling(this,val)
            validateattributes(val,{'numeric'},{'real','finite','scalar'},'','PenaltyForFalling');
            this.PenaltyForFalling = val;
        end
    end
    
    methods (Access = protected)
        % (optional) update visualization everytime the environment is updated 
        % (notifyEnvUpdated is called)
        function envUpdatedCallback(this)
        end
    end
end
